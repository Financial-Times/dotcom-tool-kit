const { loadToolKitRC } = require('../core/cli/lib/rc-file')
const { importEntryPoint, importSchemaEntryPoint } = require('../core/cli/lib/plugin/entry-point')
const { Task } = require('../lib/base')
const { invalid, reduceValidated, valid } = require('../lib/validated')
const { default: $t } = require('endent')
const logger = require('winston')
const path = require('path')
const fs = require('fs/promises')
const z = require('zod')
const { convertSchemas, formatModelsAsMarkdown } = require('zod2md')

function formatSchemas(title, schemas) {
  const converted = schemas.flatMap((schema) => {
    const converted = convertSchemas([schema])

    // for more complex types, the autogenerated schema docs aren't that readable.
    // we can hide them by adding this HTML commment in the description.
    if (converted[0]?.description?.includes('<!-- hide autogenerated schema docs -->')) {
      converted[0].type = undefined
    }

    return converted
  })

  return postProcessMarkdown(
    formatModelsAsMarkdown(converted, { title, transformName: (name) => '`' + name + '`' })
  )
}

async function formatPluginSchemas(plugin) {
  const pluginRoot = path.join('plugins', plugin)
  const rcFile = await loadToolKitRC(logger, pluginRoot, false)
  const pluginPackage = `@dotcom-tool-kit/${plugin}`
  const pluginShim = { id: pluginPackage, root: pluginRoot }

  const pluginSchemaPath = rcFile.optionsSchema
  const pluginValidSchema = pluginSchemaPath
    ? await importSchemaEntryPoint({
        plugin: pluginShim,
        modulePath: pluginSchemaPath
      })
    : undefined
  const pluginSchema = pluginValidSchema?.valid ? pluginValidSchema.value : undefined
  const tasksWithSchemas = (
    await Promise.all(
      Object.entries(rcFile.tasks).map(async ([taskName, taskPath]) => {
        const taskEntryPoint = { plugin: pluginShim, modulePath: taskPath }
        const taskSchema = await importSchemaEntryPoint(taskEntryPoint, 'schema')
        if (taskSchema.valid) {
          return valid([taskName, taskSchema.value])
        } else {
          return (await importEntryPoint(Task, taskEntryPoint)).flatMap(({ baseClass: TaskClass }) => {
            return TaskClass.description
              ? valid([taskName, z.object({}).describe(TaskClass.description)])
              : invalid(['no description'])
          })
        }
      })
    )
  )
    .filter((validated) => validated.valid)
    .map((validated) => validated.value)
  const hooksWithSchemas = (
    await Promise.all(
      Object.entries(rcFile.installs).map(async ([hookName, hookPath]) =>
        (
          await importSchemaEntryPoint({ plugin: pluginShim, modulePath: hookPath.entryPoint }, 'schema')
        ).map((hookSchema) => [hookName, hookSchema])
      )
    )
  )
    .filter((validated) => validated.valid)
    .map((validated) => validated.value)

  return $t`
    ${
      tasksWithSchemas.length
        ? formatSchemas(
            'Tasks',
            tasksWithSchemas.map(([name, schema]) => ({
              name,
              schema: schema.describe((schema.description ?? '') + '\n### Task options')
            }))
          )
        : ''
    }
    ${
      hooksWithSchemas.length
        ? formatSchemas(
            'Hooks',
            hooksWithSchemas.map(([name, schema]) => ({
              name,
              schema: schema.describe((schema.description ?? '') + '\n### Hook options')
            }))
          )
        : ''
    }
    ${
      pluginSchema
        ? formatSchemas('Plugin-wide options', [
            {
              name: pluginPackage,
              schema: pluginSchema
            }
          ])
        : ''
    }
	`
}

const schemasToRemove = () =>
  new RegExp(
    `#### (Task|Hook) options

(\\| Property \\| Type \\|
\\| :------- \\| :--- \\|

_All properties are optional._|undefined)
`,
    'g'
  )

function postProcessMarkdown(markdown) {
  return markdown
    .replace(/^#/gm, '##')
    .replace(/_Object containing the following properties:_\n\n/g, '')
    .replaceAll(schemasToRemove(), '')
}

const BEGIN_COMMENT = '<!-- begin autogenerated docs -->\n'
const END_COMMENT = '<!-- end autogenerated docs -->'

function replaceBetween(text, replaceWith, startMarker, endMarker) {
  const startIndex = text.indexOf(startMarker)
  if (startIndex === -1) {
    throw new Error(`Start marker "${startMarker}" not found`)
  }

  const endIndex = text.indexOf(endMarker, startIndex + startMarker.length)
  if (endIndex === -1) {
    throw new Error(`End marker "${endMarker}" not found after start marker "${startMarker}"`)
  }

  return text.slice(0, startIndex + startMarker.length) + replaceWith + text.slice(endIndex)
}

async function main() {
  const plugins = await fs.readdir('plugins')

  return await Promise.all(
    plugins.map(async (plugin) => {
      const readmePath = path.join('plugins', plugin, 'readme.md')
      const generatedOptionsMarkdown = await formatPluginSchemas(plugin)

      const originalReadme = await fs.readFile(readmePath, 'utf-8')

      try {
        const replacedReadme = replaceBetween(
          originalReadme,
          generatedOptionsMarkdown,
          BEGIN_COMMENT,
          END_COMMENT
        )

        await fs.writeFile(readmePath, replacedReadme, 'utf-8')
        console.log(`written ${readmePath}`)
      } catch (e) {
        console.error(`no replacement markers in ${readmePath}`)
      }
    })
  )
}

main()
