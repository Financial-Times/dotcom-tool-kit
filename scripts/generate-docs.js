const { loadToolKitRC } = require('../core/cli/lib/rc-file')
const { TaskSchemas } = require('../lib/schemas/lib/tasks')
const { HookSchemas } = require('../lib/schemas/lib/hooks')
const { PluginSchemas } = require('../lib/schemas/lib/plugins')
const { default: $t } = require('endent')
const logger = require('winston')
const path = require('path')
const fs = require('fs/promises')
const { convertSchemas, formatModelsAsMarkdown } = require('zod2md')

function formatSchemas(title, schemas) {
  const converted = convertSchemas(schemas)
  return postProcessMarkdown(
    formatModelsAsMarkdown(converted, { title, transformName: (name) => '`' + name + '`' })
  )
}

async function formatPluginSchemas(plugin) {
  const rcFile = await loadToolKitRC(logger, path.join('plugins', plugin), false)
  const pluginPackage = `@dotcom-tool-kit/${plugin}`
  const hooks = Object.keys(rcFile.installs)
  const tasks = Object.keys(rcFile.tasks)

  const tasksWithSchemas = tasks.filter((task) => TaskSchemas[task])
  const hooksWithSchemas = hooks.filter((hook) => HookSchemas[hook])
  return $t`
    ${
      tasksWithSchemas.length
        ? formatSchemas(
            'Tasks',
            tasksWithSchemas.map((task) => ({
              name: task,
              schema: TaskSchemas[task].describe((TaskSchemas[task].description ?? '') + '\n### Task options')
            }))
          )
        : ''
    }
    ${
      hooksWithSchemas.length
        ? formatSchemas(
            'Hooks',
            hooksWithSchemas.map((hook) => ({
              name: hook,
              schema: HookSchemas[hook].describe((HookSchemas[hook].description ?? '') + '\n### Hook options')
            }))
          )
        : ''
    }
    ${
      PluginSchemas[pluginPackage]
        ? formatSchemas('Plugin-wide options', [
            {
              name: pluginPackage,
              schema: PluginSchemas[pluginPackage]
            }
          ])
        : ''
    }
	`
}

const EMPTY_OBJECT_SCHEMA = `#### Task options

| Property | Type |
| :------- | :--- |

_All properties are optional._`

function postProcessMarkdown(markdown) {
  return markdown
    .replace(/^#/gm, '##')
    .replace(/_Object containing the following properties:_\n\n/g, '')
    .replaceAll(EMPTY_OBJECT_SCHEMA, '')
}

const BEGIN_COMMENT = '<!-- begin autogenerated docs -->\n'
const END_COMMENT = '<!-- end autogenerated docs -->'

function replaceBetween(text, replaceWith, startMarker, endMarker) {
  const startIndex = text.indexOf(startMarker)
  if (startIndex === -1) {
    throw new Error(`Start marker "${startMarker}" not found`)
  }

  const endIndex = text.indexOf(endMarker, startIndex + startMarker.length)
  if (endIndex === -1) {
    throw new Error(`End marker "${endMarker}" not found after start marker "${startMarker}"`)
  }

  return text.slice(0, startIndex + startMarker.length) + replaceWith + text.slice(endIndex)
}

async function main() {
  const plugins = await fs.readdir('plugins')

  return await Promise.all(
    plugins.map(async (plugin) => {
      const readmePath = path.join('plugins', plugin, 'readme.md')
      const generatedOptionsMarkdown = await formatPluginSchemas(plugin)

      const originalReadme = await fs.readFile(readmePath, 'utf-8')

      try {
        const replacedReadme = replaceBetween(
          originalReadme,
          generatedOptionsMarkdown,
          BEGIN_COMMENT,
          END_COMMENT
        )

        await fs.writeFile(readmePath, replacedReadme, 'utf-8')
        console.log(`written ${readmePath}`)
      } catch (e) {
        console.error(`no replacement markers in ${readmePath}`)
      }
    })
  )
}

main()
