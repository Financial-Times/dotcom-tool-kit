import { describe, it, expect } from '@jest/globals'
import path from 'path'
import CircleCiConfigHook from '../src/circleci-config'
import * as YAML from 'yaml'
import fs from 'fs'
import winston, { Logger } from 'winston'
import { semVerRegex } from '@dotcom-tool-kit/types/lib/npm'

const logger = (winston as unknown) as Logger

jest.mock('fs', () => {
  const originalModule = jest.requireActual('fs')

  return {
    ...originalModule,
    promises: { ...originalModule.promises, writeFile: jest.fn() }
  }
})
const mockedWriteFile = jest.mocked(fs.promises.writeFile)

describe('CircleCI config hook', () => {
  class TestHook extends CircleCiConfigHook {
    job = 'test-job'
    jobOptions = {
      requires: ['another-job']
    }
    addToNightly = true
  }
  class TestTaggedHook extends CircleCiConfigHook {
    job = 'test-tagged-job'
    jobOptions = {
      requires: ['another-job']
    }
    runOnVersionTags = true
  }

  const originalDir = process.cwd()

  afterEach(() => {
    process.chdir(originalDir)
  })

  describe('check', () => {
    it('should return true if the hook job is in the circleci workflow', async () => {
      process.chdir(path.join(__dirname, 'files', 'with-hook'))
      const hook = new TestHook(logger)
      expect(await hook.check()).toBeTruthy()
    })

    it('should return false if the hook job is not in the circleci workflow', async () => {
      process.chdir(path.join(__dirname, 'files', 'without-hook'))
      const hook = new TestHook(logger)
      expect(await hook.check()).toBeFalsy()
    })
  })

  describe('install', () => {
    it('should throw an error explaining what to do if no autogenerated comment', async () => {
      process.chdir(path.join(__dirname, 'files', 'without-hook'))
      const hook = new TestHook(logger)
      const state = await hook.install()
      await expect(hook.commitInstall(state)).rejects.toThrow('Please update your CircleCI config to include')
    })

    it(`should add a job with its jobConfig to a file with a comment if it's not there`, async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger)
      const state = await hook.install()
      await hook.commitInstall(state)

      const config = YAML.parse(mockedWriteFile.mock.calls[0][1])
      expect(config).toEqual(
        expect.objectContaining({
          workflows: {
            'tool-kit': expect.objectContaining({
              jobs: expect.arrayContaining([
                expect.objectContaining({
                  'test-job': expect.objectContaining({
                    requires: ['another-job']
                  })
                })
              ])
            }),
            nightly: expect.objectContaining({
              jobs: expect.arrayContaining([
                {
                  'test-job': expect.objectContaining({
                    requires: ['another-job']
                  })
                }
              ])
            })
          }
        })
      )
    })

    it(`should add a tag filter to all jobs if one job requires it`, async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger)
      const taggedHook = new TestTaggedHook(logger)
      let state = await hook.install()
      state = await taggedHook.install(state)
      await hook.commitInstall(state)

      const semverFilter = `/${semVerRegex.source}/`
      const config = YAML.parse(mockedWriteFile.mock.calls[0][1])
      expect(config).toEqual(
        expect.objectContaining({
          workflows: {
            'tool-kit': expect.objectContaining({
              jobs: expect.arrayContaining([
                expect.objectContaining({
                  'test-job': expect.objectContaining({
                    requires: ['another-job'],
                    filters: { tags: { only: semverFilter } }
                  })
                }),
                expect.objectContaining({
                  'test-tagged-job': expect.objectContaining({
                    requires: ['another-job'],
                    filters: { tags: { only: semverFilter } }
                  })
                })
              ])
            }),
            nightly: expect.objectContaining({
              jobs: expect.arrayContaining([
                expect.objectContaining({
                  'test-job': expect.objectContaining({
                    requires: ['another-job']
                  })
                })
              ])
            })
          }
        })
      )
    })
  })
})
