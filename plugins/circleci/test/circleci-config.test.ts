import fs from 'fs'
import path from 'path'

import { describe, expect, it } from '@jest/globals'
import winston, { type Logger } from 'winston'
import * as YAML from 'yaml'

import { setOptions } from '@dotcom-tool-kit/options/lib'

import CircleCiConfigHook, { generateConfigWithJob } from '../src/circleci-config'

const logger = winston as unknown as Logger

jest.mock('fs', () => {
  const originalModule = jest.requireActual('fs')

  return {
    ...originalModule,
    promises: { ...originalModule.promises, writeFile: jest.fn() }
  }
})
const mockedWriteFile = jest.mocked(fs.promises.writeFile)

describe('CircleCI config hook', () => {
  abstract class FakeCircleCiConfigHook extends CircleCiConfigHook {
    // pretend it's never the first time we've opened the config so that we
    // skip the comparison with the base config generated by getInitialState()
    haveCheckedBaseConfig = true
  }
  class TestHook extends FakeCircleCiConfigHook {
    config = generateConfigWithJob({
      name: 'test-job',
      addToNightly: true,
      requires: ['waiting-for-approval', 'that-job'],
      splitIntoMatrix: false
    })
  }
  class TestAnotherHook extends FakeCircleCiConfigHook {
    config = generateConfigWithJob({
      name: 'test-another-job',
      addToNightly: false,
      requires: ['waiting-for-approval', 'this-job'],
      splitIntoMatrix: true
    })
  }

  const originalDir = process.cwd()

  beforeAll(() => {
    // mirror the default options created by zod
    setOptions('@dotcom-tool-kit/circleci', { nodeVersion: '16.14-browsers' })
  })

  afterEach(() => {
    process.chdir(originalDir)
  })

  describe('check', () => {
    it('should return true if the hook job is in the circleci workflow', async () => {
      process.chdir(path.join(__dirname, 'files', 'with-hook'))
      const hook = new TestHook(logger, 'TestHook')
      expect(await hook.isInstalled()).toBeTruthy()
    })

    it('should return false if the hook job is not in the circleci workflow', async () => {
      process.chdir(path.join(__dirname, 'files', 'without-hook'))
      const hook = new TestHook(logger, 'TestHook')
      expect(await hook.isInstalled()).toBeFalsy()
    })

    it('should return false if the base configuration is missing', async () => {
      process.chdir(path.join(__dirname, 'files', 'with-hook'))
      const hook = new TestHook(logger, 'TestHook')
      // reset field overridden by FakeCircleCiConfigHook so that we do check
      // for the base config
      hook.haveCheckedBaseConfig = false
      expect(await hook.isInstalled()).toBeFalsy()
    })
  })

  describe('install', () => {
    it("should throw an error explaining how to autogenerate config if existing config file doesn't contain any tool-kit jobs", async () => {
      process.chdir(path.join(__dirname, 'files', 'without-tool-kit'))
      const hook = new TestHook(logger, 'TestHook')
      const state = await hook.install()
      await expect(hook.commitInstall(state)).rejects.toThrow(
        "Your project has an existing CircleCI config file which doesn't contain"
      )
    })

    it('should throw an error explaining what to do if no autogenerated comment', async () => {
      process.chdir(path.join(__dirname, 'files', 'without-hook'))
      const hook = new TestHook(logger, 'TestHook')
      const state = await hook.install()
      await expect(hook.commitInstall(state)).rejects.toThrow(
        'Your CircleCI configuration is missing the expected fields from Tool Kit:'
      )
    })

    it("should add a job with its jobConfig to a file with a comment if it's not there", async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger, 'TestHook')
      const state = await hook.install()
      await hook.commitInstall(state)

      const config = YAML.parse(mockedWriteFile.mock.calls[0][1] as string)
      expect(config).toEqual(
        expect.objectContaining({
          workflows: {
            'tool-kit': expect.objectContaining({
              jobs: expect.arrayContaining([
                expect.objectContaining({
                  'test-job': expect.objectContaining({
                    requires: ['waiting-for-approval', 'that-job-node']
                  })
                })
              ])
            }),
            nightly: expect.objectContaining({
              jobs: expect.arrayContaining([
                {
                  'test-job': expect.objectContaining({
                    requires: ['that-job-node']
                  })
                }
              ])
            })
          }
        })
      )
    })

    it('should merge jobs from two hooks', async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger, 'TestHook')
      const anotherHook = new TestAnotherHook(logger, 'TestAnotherHook')
      let state = await hook.install()
      state = await anotherHook.install(state)
      await hook.commitInstall(state)

      const config = YAML.parse(mockedWriteFile.mock.calls[0][1] as string)
      expect(config).toEqual(
        expect.objectContaining({
          workflows: {
            'tool-kit': expect.objectContaining({
              jobs: expect.arrayContaining([
                expect.objectContaining({
                  'test-job': expect.objectContaining({
                    requires: ['waiting-for-approval', 'that-job-node']
                  })
                }),
                expect.objectContaining({
                  'test-another-job': expect.objectContaining({
                    requires: ['waiting-for-approval', 'this-job-<< matrix.executor >>']
                  })
                })
              ])
            }),
            nightly: expect.objectContaining({
              jobs: expect.arrayContaining([
                {
                  'test-job': expect.objectContaining({
                    requires: ['that-job-node']
                  })
                }
              ])
            })
          }
        })
      )
    })

    it('should discard job from duplicate hook', async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger, 'TestHook')
      const sameHook = new TestHook(logger, 'TestHook')
      let state = await hook.install()
      state = await sameHook.install(state)
      await hook.commitInstall(state)

      const config = YAML.parse(mockedWriteFile.mock.calls[0][1] as string)
      const partialExpectedJob = {
        'test-job': expect.objectContaining({
          requires: ['waiting-for-approval', 'that-job-node']
        })
      }
      const { jobs } = config.workflows['tool-kit']
      expect(jobs).toHaveLength(4)
      for (let i = 0; i < 3; i++) {
        expect(jobs[i]).toEqual(expect.not.objectContaining(partialExpectedJob))
      }
      expect(jobs[3]).toEqual(expect.objectContaining(partialExpectedJob))
    })

    it('correctly generates a new configuration file', async () => {
      process.chdir(path.join(__dirname, 'files', 'comment-without-hook'))

      const hook = new TestHook(logger, 'TestHook')
      const anotherHook = new TestAnotherHook(logger, 'TestAnotherHook')
      let state = await hook.install()
      state = await anotherHook.install(state)
      await hook.commitInstall(state)

      const config = YAML.parse(mockedWriteFile.mock.calls[0][1] as string)
      expect(config).toMatchSnapshot()
    })
  })
})
