import { promises as fs } from 'fs'
import merge from 'lodash/merge'
import path from 'path'
import YAML from 'yaml'
import { ToolKitError } from '@dotcom-tool-kit/error'
import { styles } from '@dotcom-tool-kit/logger'
import { getOptions } from '@dotcom-tool-kit/options'
import { Hook } from '@dotcom-tool-kit/types'
import { semVerRegex } from '@dotcom-tool-kit/types/lib/npm'
import { Workflow, JobConfig, CircleConfig, automatedComment, Job } from '@dotcom-tool-kit/types/lib/circleci'

const majorOrbVersion = '2'

interface CircleCIState {
  jobs: Record<string, JobConfig>
  nightlyJobs: Record<string, JobConfig>
  runOnVersionTags: boolean
  additionalFields: Record<string, unknown>
}

const tagFilter = { filters: { tags: { only: `${semVerRegex}` } } }

const isAutomatedConfig = (config: string): boolean => config.startsWith(automatedComment)

const isNotToolKitConfig = (config: string): boolean => !config.includes('tool-kit')

const hasJob = (expectedJob: string, jobs: NonNullable<Workflow['jobs']>): boolean =>
  jobs.some(
    (job) =>
      (typeof job === 'string' && job === expectedJob) ||
      (typeof job === 'object' && job.hasOwnProperty(expectedJob))
  )

function getWorkflowJobs(config: CircleConfig): { jobs?: Job[]; nightlyJobs?: Job[] } {
  const workflows = config?.workflows as Record<string, Workflow | undefined> | undefined
  const jobs = workflows?.['tool-kit']?.jobs
  const nightlyJobs = workflows?.['nightly']?.jobs

  return { jobs, nightlyJobs }
}

export default abstract class CircleCiConfigHook extends Hook<CircleCIState> {
  installGroup = 'circleci'

  circleConfigPath = path.resolve(process.cwd(), '.circleci/config.yml')
  _circleConfig?: string
  _versionTag?: string
  abstract job: string
  abstract jobOptions: JobConfig
  additionalFields?: Record<string, unknown>
  addToNightly?: boolean
  runOnVersionTags?: boolean

  async getCircleConfig(): Promise<string | undefined> {
    if (!this._circleConfig) {
      try {
        this.logger.verbose(`trying to read CircleCI config at ${styles.filepath(this.circleConfigPath)}...`)
        this._circleConfig = await fs.readFile(this.circleConfigPath, 'utf8')
      } catch (err) {
        // Not an error if config file doesn't exist
        if ((err as NodeJS.ErrnoException).code !== 'ENOENT') {
          throw err
        }
      }
    }

    return this._circleConfig
  }

  async check(): Promise<boolean> {
    const rawConfig = await this.getCircleConfig()
    if (!rawConfig) {
      return false
    }
    const config = YAML.parse(rawConfig) as CircleConfig

    // Automatically update tool kit orb if config is autogenerated
    if (isAutomatedConfig(rawConfig)) {
      const currentOrb = config?.orbs['tool-kit']
      const currentMajorTag = currentOrb && currentOrb.split('@')[1].split('.')[0]

      if (majorOrbVersion !== currentMajorTag) {
        return false
      }
    }

    const { jobs, nightlyJobs } = getWorkflowJobs(config)
    if (!(jobs && hasJob(this.job, jobs))) {
      return false
    }
    if (this.addToNightly && !(nightlyJobs && hasJob(this.job, nightlyJobs))) {
      return false
    }
    return true
  }

  async install(state?: CircleCIState): Promise<CircleCIState> {
    if (!state) {
      state = {
        jobs: {},
        nightlyJobs: {},
        runOnVersionTags: false,
        additionalFields: {}
      }
    }

    state.jobs[this.job] = this.jobOptions
    if (this.addToNightly) {
      state.nightlyJobs[this.job] = this.jobOptions
    }
    if (this.runOnVersionTags) {
      state.runOnVersionTags = true
    }
    merge(state.additionalFields, this.additionalFields)
    return state
  }

  async commitInstall(state: CircleCIState): Promise<void> {
    const rawConfig = await this.getCircleConfig()

    if (rawConfig && isNotToolKitConfig(rawConfig)) {
      throw new ToolKitError(
        `Your project has an existing CircleCI config file which doesn't contain a ${styles.heading(
          'tool-kit'
        )} workflow.
If you would like a Tool Kit configured CircleCI config file to be generated for you please delete your existing CircleCI ${styles.filepath(
          'config.yml'
        )} and re-run: ${styles.code('npx dotcom-tool-kit --install')}`
      )
    }

    if (rawConfig && !isAutomatedConfig(rawConfig)) {
      const config = YAML.parse(rawConfig)
      const { jobs, nightlyJobs } = getWorkflowJobs(config)
      const flattenJob = (job: Job): string => (typeof job === 'string' ? job : Object.keys(job)[0])
      const flatJobs = jobs?.map(flattenJob) ?? []
      const flatNightlyJobs = nightlyJobs?.map(flattenJob) ?? []
      const missingJobs = Object.keys(state.jobs).filter((job) => !flatJobs.includes(job))
      const missingNightlyJobs = Object.keys(state.nightlyJobs).filter(
        (job) => !flatNightlyJobs.includes(job)
      )

      const formatMissingHooks = (hooks: string[]): string => hooks.map(styles.hook).join(', ')
      throw new ToolKitError(
        `Please update your CircleCI config to include ${
          missingJobs.length > 0
            ? `the ${formatMissingHooks(missingJobs)} job(s) in the ${styles.heading('tool-kit')} workflow`
            : ''
        }${missingJobs.length > 0 && missingNightlyJobs.length > 0 ? ' and ' : ''}${
          missingNightlyJobs.length > 0
            ? `the ${formatMissingHooks(missingNightlyJobs)} job(s) in the ${styles.heading(
                'nightly'
              )} workflow`
            : ''
        }`
      )
    }

    const nodeVersion = getOptions('@dotcom-tool-kit/circleci')?.nodeVersion
    const newConfig: Record<string, unknown> = {
      version: 2.1,
      orbs: {
        'tool-kit': process.env.TOOL_KIT_FORCE_DEV_ORB
          ? 'financial-times/dotcom-tool-kit@dev:alpha'
          : `financial-times/dotcom-tool-kit@${majorOrbVersion}`
      },
      jobs: {
        checkout: {
          docker: [{ image: 'cimg/base:stable' }],
          steps: [
            'checkout',
            {
              'tool-kit/persist-workspace': {
                path: '.'
              }
            }
          ]
        }
      },
      workflows: {
        'tool-kit': {
          when: {
            not: {
              equal: ['scheduled_pipeline', '<< pipeline.trigger_source >>']
            }
          },
          jobs: [
            state.runOnVersionTags ? { checkout: tagFilter } : 'checkout',
            {
              'waiting-for-approval': {
                type: 'approval',
                filters: { branches: { only: '/(^renovate-.*|^nori/.*)/' } }
              }
            },
            ...[
              {
                'tool-kit/setup': {
                  requires: ['checkout', 'waiting-for-approval']
                }
              },
              ...Object.entries(state.jobs).map(([job, options]) => ({
                [job]: {
                  ...options
                }
              }))
            ].map((job) => {
              const options = Object.values(job)[0] // there should only ever be one field on the job
              if (nodeVersion) {
                options.executor ??= 'node'
              }
              if (state.runOnVersionTags) {
                merge(options, tagFilter)
              }
              return job
            })
          ]
        },
        nightly: {
          when: {
            and: [
              {
                equal: ['scheduled_pipeline', '<< pipeline.trigger_source >>']
              },
              {
                equal: ['nightly', '<< pipeline.schedule.name >>']
              }
            ]
          },
          jobs: [
            'checkout',
            ...[
              {
                'tool-kit/setup': {
                  requires: ['checkout']
                }
              },
              ...Object.entries(state.nightlyJobs).map(([job, options]) => ({
                [job]: {
                  ...options,
                  requires: options.requires?.filter((x: string) => x !== 'waiting-for-approval')
                }
              }))
            ].map((job) => {
              if (nodeVersion) {
                Object.values(job)[0].executor ??= 'node'
              }
              return job
            })
          ]
        }
      }
    }
    if (nodeVersion) {
      newConfig.executors = { node: { docker: [{ image: `cimg/node:${nodeVersion}` }] } }
    }
    merge(newConfig, state.additionalFields)

    const serialised = automatedComment + YAML.stringify(newConfig, { aliasDuplicateObjects: false })
    const circleConfigDir = path.dirname(this.circleConfigPath)
    this.logger.verbose(`making directory at ${styles.filepath(circleConfigDir)}...`)
    // Enable recursive option so that mkdir doesn't throw if the directory
    // already exists.
    await fs.mkdir(circleConfigDir, { recursive: true })
    this.logger.info(`writing CircleCI config to ${styles.filepath(this.circleConfigPath)}...`)
    await fs.writeFile(this.circleConfigPath, serialised)
  }
}
