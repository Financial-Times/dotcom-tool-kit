import { Task, TaskRunContext } from '@dotcom-tool-kit/base'
import { styles } from '@dotcom-tool-kit/logger'
import { z } from 'zod'
import { type ErrorSummary, handleTaskErrors, loadTasks } from 'dotcom-tool-kit/lib/tasks'
import { ValidConfig } from '@dotcom-tool-kit/config'
import type { WritableDeep } from 'type-fest'

const ParallelSchema = z.object({
  tasks: z.array(z.record(z.record(z.unknown()))),
  stopOnError: z.boolean().default(false)
}).describe(`Run Tool Kit tasks in parallel

### Task options

#### \`tasks\`

An array listing the tasks to run in parallel, and the options to run each task with. Each element in the array is an object with a single key and value; the key is the name of the task to run, and the value is the options object for that task. Other tasks' options are documented in their plugin's readme.

##### Example

~~~yaml
commands:
  run:local:
    - Parallel:
        tasks:
          - Node:
              entry: server/index.js
          - Webpack:
              watch: true
~~~

#### \`stopOnError\`

An optional \`boolean\`, defaulting to \`false\`. If \`true\`, when one of the parallel tasks throws an error, \`Parallel\` will stop the other tasks. This is useful for long-running tasks, e.g. a Node server and Webpack in \`watch\` mode, where one task erroring means you don't have everything running that you'd expect. If you're using \`Parallel\` to run shorter tasks in parallel as an optimisation, keep this as the default \`false\` so every task runs to completion and Tool Kit can show the final results of all the tasks.

<!-- hide autogenerated schema docs -->
`)

export { ParallelSchema as schema }

export default class Parallel extends Task<{ task: typeof ParallelSchema }> {
  async run(context: TaskRunContext) {
    const tasks = this.options.tasks.flatMap((entry) =>
      Object.entries(entry).map(([task, options]) => ({ task, options, plugin: this.plugin }))
    )

    this.logger.info(`running tasks in parallel:
${tasks
  .map(
    (task) =>
      `  - ${styles.task(task.task)} ${styles.dim(
        `(with options ${styles.code(JSON.stringify(task.options))})`
      )}`
  )
  .join('\n')}
`)

    // HACK:KB:20250619 loadTasks expects config to be mutable, in TaskRunContext it's readonly, just cast it idc
    const taskInstances = (
      await loadTasks(this.logger, tasks, context.config as WritableDeep<ValidConfig>)
    ).unwrap('tasks are invalid!')

    if (this.options.stopOnError) {
      try {
        await Promise.all(taskInstances.map((task) => task.run(context)))
      } catch (error) {
        await Promise.all(
          taskInstances.map((task) =>
            task.stop().catch((error) => {
              this.logger.warn(`error stopping ${styles.task(this.id)}:
  ${error.message}`)
            })
          )
        )

        throw error
      }
    } else {
      const errors: ErrorSummary[] = []

      await Promise.all(
        taskInstances.map((task) =>
          task.run(context).catch((error: Error) => {
            errors.push({
              task: task.id,
              error
            })
          })
        )
      )

      if (errors.length > 0) {
        handleTaskErrors(errors, context.command)
      }
    }
  }
}
