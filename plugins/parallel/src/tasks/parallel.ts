import { Task, TaskRunContext } from '@dotcom-tool-kit/base'
import { styles } from '@dotcom-tool-kit/logger'
import { z } from 'zod/v3'
import { type ErrorSummary, handleTaskErrors, loadTasks } from 'dotcom-tool-kit/lib/tasks'
import { ToolKitError } from '@dotcom-tool-kit/error'

const ParallelSchema = z.object({
  tasks: z.array(z.record(z.record(z.unknown()))),
  onError: z.union([z.literal('stop-all'), z.literal('wait-for-others')]).default('wait-for-others')
}).describe(`Run Tool Kit tasks in parallel

### Task options

#### \`tasks\`

An array listing the tasks to run in parallel, and the options to run each task with. Each element in the array is an object with a single key and value; the key is the name of the task to run, and the value is the options object for that task. Other tasks' options are documented in their plugin's readme.

##### Example

~~~yaml
commands:
  run:local:
    - Parallel:
        tasks:
          - Node:
              entry: server/index.js
          - Webpack:
              watch: true
~~~

#### \`onError\`

_optional_

| Value | Description |
|-|-|
| \`'wait-for-others'\` (default) | If any task errors, wait for the other tasks to complete, and print all the errors at the end. |
| \`'stop-all'\` | If any task errors, immediately stop the other tasks, and print the error. |

For long-running tasks, e.g. a Node server and Webpack in \`watch\` mode, it's possible for one task to error, but its error logging to be buried by the other tasks' output, meaning you might have missed an error and aren't aware that not everything you expect to be running is still running. In these cases, set \`onError: stop-all\`; Tool Kit will exit every \`Parallel\` task if one of them errors, so you're always in a consistent state and don't miss any errors.

If you're using \`Parallel\` to run shorter tasks in parallel as an optimisation, keep this as the default \`wait-for-others\` so every task runs to completion and Tool Kit can show the final results of all the tasks.

<!-- hide autogenerated schema docs -->
`)

export { ParallelSchema as schema }

export default class Parallel extends Task<{ task: typeof ParallelSchema }> {
  taskInstances: Task<any>[] = []

  async run(context: TaskRunContext) {
    const tasks = this.options.tasks.flatMap((entry) =>
      Object.entries(entry).map(([task, options]) => ({ task, options, plugin: this.plugin }))
    )

    this.logger.info(`running tasks in parallel:
${tasks
  .map(
    (task) =>
      `  - ${styles.task(task.task)} ${styles.dim(
        `(with options ${styles.code(JSON.stringify(task.options))})`
      )}`
  )
  .join('\n')}
`)

    this.taskInstances = (await loadTasks(this.logger, tasks, context.config)).unwrap('tasks are invalid!')

    switch (this.options.onError) {
      case 'stop-all': {
        try {
          await Promise.all(this.taskInstances.map((task) => task.run(context)))
        } catch (error) {
          this.stop()
          throw error
        }
        break
      }
      case 'wait-for-others': {
        const errors: ErrorSummary[] = []

        await Promise.all(
          this.taskInstances.map((task) =>
            task.run(context).catch((error: Error) => {
              errors.push({
                task: task.id,
                error
              })
            })
          )
        )

        if (errors.length > 0) {
          handleTaskErrors(errors, context.command)
        }

        break
      }
      default: {
        this.assertUnreachable('Parallel.options.onError', this.options.onError)
      }
    }
  }

  async stop() {
    await Promise.all(
      this.taskInstances.map((task) =>
        task.stop().catch((error) => {
          this.logger.warn(`error stopping ${styles.task(task.id)}:
${error.message}`)
        })
      )
    )
  }

  assertUnreachable(label: string, value: never): asserts value is never {
    const error = new ToolKitError(`Unexpected value for ${label}, received ${value}`)
    error.details = 'This should never happen! Talk to #cp-platforms-team, something weird af is going on'
    throw error
  }
}
