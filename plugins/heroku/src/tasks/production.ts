import { Task } from '@dotcom-tool-kit/base'
import { ToolKitError } from '@dotcom-tool-kit/error'
import { readState } from '@dotcom-tool-kit/state'
import { styles } from '@dotcom-tool-kit/logger'
import type { HerokuApiResGetApp } from 'heroku-client'
import heroku, { extractHerokuError } from '../herokuClient'
import { scaleDyno } from '../scaleDyno'
import HerokuSchema from '../schema'
import { promoteStagingToProduction } from '../promoteStagingToProduction'
import * as z from 'zod'

const HerokuScalingSchema = z.record(
  z.record(
    z.object({
      size: z.string(),
      quantity: z.number()
    })
  )
)
const HerokuProductionSchema = z.object({
  scaling: HerokuScalingSchema
}).describe(`Promote the Heroku staging app to production.

### Task options

\`scaling\`: an object with scaling configuration for each app and dyno. The first-level keys are the names of your production apps, and the second level keys are names of the dynos within each app (this should usually at least include \`web\`).

#### Scaling configuration

| Property | Description | Type |
|-|-|-|
| \`size\` | the [Dyno type](https://devcenter.heroku.com/articles/dyno-types) for this dyno, e.g. \`standard-1x\`. apps in the FT Heroku account can only use [professional tier dynos](https://devcenter.heroku.com/articles/dyno-types#dyno-tiers-and-mixing-dyno-types). | \`string\` |
| \`quantity\` | how many of this dyno to use | \`number\` |

#### Example

~~~yml
options:
  tasks:
    HerokuProduction:
      scaling:
        ft-next-static-eu:
          web:
            size: standard-1x
            quantity: 1
~~~

<!-- hide autogenerated schema docs -->
`)
export { HerokuProductionSchema as schema }

export default class HerokuProduction extends Task<{
  plugin: typeof HerokuSchema
  task: typeof HerokuProductionSchema
}> {
  async run(): Promise<void> {
    try {
      this.logger.verbose('retrieving staging slug...')
      const state = readState('staging')
      if (!state) {
        throw new ToolKitError('could not find staging state information')
      }
      const { slugId } = state

      const { scaling } = this.options

      const scale = async () => {
        for (const [appName, typeConfig] of Object.entries(scaling)) {
          this.logger.verbose(`scaling app ${styles.app(appName)}...`)
          for (const [processType, { quantity, size }] of Object.entries(typeConfig)) {
            await scaleDyno(this.logger, appName, quantity, processType, size)
          }
          this.logger.info(`${styles.app(appName)} has been successfully scaled`)
        }
      }
      const promote = async () => {
        this.logger.verbose('promoting staging to production....')
        await promoteStagingToProduction(this.logger, slugId)
        this.logger.info('staging has been successfully promoted to production')
      }

      const productionState = readState('production')
      const appIds = productionState?.appIds ?? []

      // We want to scale apps before promoting them to production as the
      // preboot phase after promotion can take minutes and scaling is not
      // possible during that time. However, scaling will fail if this is the
      // first time the app has been deployed, so do the deployment first then.
      // Hopefully, there shouldn't be a preboot phase if we don't need to
      // switch from an old version either so it should be safe to scale the
      // app immediately afterwards. Maybe.
      if (await this.fetchIfAppHasDeployed(appIds[0])) {
        await scale()
        await promote()
      } else {
        // HACK: the simplest way to test Heroku changes
        this.logger.info(
          'if you see this log in CircleCI then please message the #cp-platforms-team and receive a free drink of your choice'
        )
        await promote()
        await scale()
      }
    } catch (err) {
      if (err instanceof ToolKitError) {
        throw err
      }

      const error = new ToolKitError("there's an error with your production app")
      if (err instanceof Error) {
        error.details = err.message
      }
      throw error
    }
  }

  async fetchIfAppHasDeployed(appId: string): Promise<boolean> {
    this.logger.verbose(`retrieving app info for ${appId}`)
    const appInfo = await heroku
      .get<HerokuApiResGetApp>(`/apps/${appId}`)
      .catch(extractHerokuError(`getting slug size for app ${appId}`))
    return appInfo.slug_size !== null
  }
}
